# SparseMatrixAdditionCPP
Efficiently add sparse matrices with ease using C++, optimizing memory and computation, in this repository showcasing intuitive operator overloading and dynamic memory allocation.

The code defines two classes: Elements and Sparse. The Elements class serves as a structure to hold the information of a single non-zero element. It contains three member variables: i to store the row index, j to store the column index, and x to store the value of the non-zero element.

The Sparse class manages the sparse matrix representation. It has private member variables m and n to store the dimensions of the matrix, num to store the total number of non-zero elements, and a pointer e to dynamically allocate memory for an array of Elements objects.

The input for the sparse matrix is obtained using the >> operator overload defined as a friend function for the Sparse class. The user is prompted to enter the non-zero elements along with their row and column indices. The input is then stored in the array of Elements objects.

The output for the sparse matrix is displayed using the << operator overload also defined as a friend function for the Sparse class. The matrix is printed by iterating over each element of the matrix dimensions. If the current row and column match the indices of a non-zero element, its value is printed; otherwise, a 0 is printed.

The addition of two sparse matrices is performed using the + operator overload defined as a member function for the Sparse class. The addition logic iterates over both matrices, comparing their row and column indices. If the indices match, the corresponding non-zero elements are added together, and a new non-zero element is created with the sum. The resulting sparse matrix is dynamically allocated and returned as the sum.
# Advantages of Friend Functions:
Access to Private Members: Friend functions have access to the private members of a class. In the code, the operator>> and operator<< functions are declared as friend functions for the Sparse class. This allows them to directly access and modify the private member variables of the Sparse class, such as m, n, num, and e. It enables convenient input and output operations on the sparse matrix without the need for getters and setters.

Symmetry and Code Readability: Friend functions can improve the readability and symmetry of code. By declaring operator>> and operator<< as friend functions, the input and output operations for the Sparse class can be written in a natural and intuitive way. It allows using the familiar syntax of cin >> s1; and cout << s1; instead of invoking member functions.
# Advantages of Member Functions:
Access to Object's Data: Member functions have direct access to the object's data members, including private variables. In the code, the operator+ function is defined as a member function for the Sparse class. It can access the private members m, n, num, and e of both the current object and the passed object. This direct access simplifies the implementation of the addition logic.

Implicit Object Access: Member functions have implicit access to the object on which they are invoked. This means that within a member function, you can access the object's data members and call other member functions directly. In the code, the operator+ member function can be called using the s1 + s2 syntax, where s1 is the implicit object. This enhances code readability and allows natural expression of operations.
# Summary
The above logic utilizes a sparse representation instead of a traditional two-dimensional array to store matrices for several reasons. Sparse matrices often have a large number of zero elements, which leads to inefficient memory usage if stored as a dense array. By storing only the non-zero elements along with their indices, the memory efficiency significantly improves. This is particularly beneficial when dealing with large matrices. Additionally, computational efficiency is enhanced as operations can be optimized by considering only the non-zero elements, resulting in faster computations. The sparse representation also provides flexibility in handling matrices with varying sparsity patterns, accommodating different matrix sizes and numbers of non-zero elements. Furthermore, input and output operations are more efficient as there is no need to handle the zero elements during user interaction or data storage. Overall, using the sparse representation offers memory efficiency, computational speedup, flexibility, and improved input/output performance compared to dense array representations.
